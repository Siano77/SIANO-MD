mkdir md-bot && cd md-bot
npm init -y
md-bot/
â”‚â”€â”€ package.json
â”‚â”€â”€ .gitignore
â”‚â”€â”€ .env.example
â”‚â”€â”€ README.md
â”‚â”€â”€ Procfile                 # optional (Heroku-style)
â”‚â”€â”€ Dockerfile               # optional (Docker/VPS)
â”‚
â””â”€â”€ src/
    â”‚â”€â”€ index.js
    â”‚â”€â”€ handler.js
    â”‚
    â”œâ”€â”€ utils/
    â”‚   â”œâ”€â”€ config.js
    â”‚   â”œâ”€â”€ store.js
    â”‚   â”œâ”€â”€ spamGuard.js
    â”‚   â””â”€â”€ moderation.js
    â”‚
    â””â”€â”€ commands/
        â”œâ”€â”€ help.js
        â”œâ”€â”€ fun.js
        â”œâ”€â”€ media.js
        â”œâ”€â”€ admin.js
        â”œâ”€â”€ welcome.js
{
  "name": "Siano-MD",
  "version": "1.0.0",
  "description": "Wake Up To Reality ğŸ’¥",
  "main": "src/index.js",
  "type": "commonjs",
  "license": "MIT",
  "scripts": {
    "start": "node src/index.js"
  },
  "dependencies": {
    "@whiskeysockets/baileys": "^6.7.7",
    "axios": "^1.7.4",
    "dotenv": "^16.4.5",
    "pino": "^9.3.2",
    "ytdl-core": "^4.11.5",
    "yt-search": "^2.10.6"
  }
}
node_modules
.env
session/
data/
PREFIX=#
OWNER_NUMBER=2347043387336
BOT_NAME=SIANO-MD
require('dotenv').config()
const pino = require('pino')
const { default: makeWASocket, useMultiFileAuthState, fetchLatestBaileysVersion, downloadMediaMessage } = require('@whiskeysockets/baileys')
const handleMessage = require('./handler')
const { getGroupSettings, ensureStore } = require('./utils/store')
const { handleAntiLinkOnMessage } = require('./utils/moderation')

const logger = pino({ level: 'info' })

async function start() {
  ensureStore()
  const { state, saveCreds } = await useMultiFileAuthState('session')
  const { version } = await fetchLatestBaileysVersion()

  const sock = makeWASocket({ version, logger, auth: state, printQRInTerminal: true })
  sock.ev.on('creds.update', saveCreds)

  // Main message pipeline
  sock.ev.on('messages.upsert', async ({ messages }) => {
    const m = messages[0]
    if (!m || !m.message) return

    // Antiâ€‘link moderation for all texts
    try { await handleAntiLinkOnMessage(sock, m) } catch (e) { logger.warn({ e }, 'antilink check failed') }

    // Commands
    try { await handleMessage(sock, m) } catch (e) { logger.error({ e }, 'handler failed') }
  })

  // Welcome messages
  sock.ev.on('group-participants.update', async (update) => {
    try {
      const chat = update.id
      const settings = getGroupSettings(chat)
      if (!settings.welcome || update.action !== 'add') return
      const user = update.participants[0]
      const text = (settings.welcomeText || 'Welcome to the group, @user ğŸ‰').replace(/@user/g, `@${user.split('@')[0]}`)
      await sock.sendMessage(chat, { text, mentions: [user] })
    } catch (e) { logger.warn({ e }, 'welcome failed') }
  })
}

start()
const { # } = require('./utils/config')
const { isSpamming } = require('./utils/spamGuard')
const fun = require('./commands/fun')
const media = require('./commands/media')
const admin = require('./commands/admin')
const welcome = require('./commands/welcome')
const help = require('./commands/help')

const all = { ...fun, ...media, ...admin, ...welcome, ...help }

function bodyOf(msg) {
  const m = msg.message
  return (
    m?.conversation ||
    m?.extendedTextMessage?.text ||
    m?.imageMessage?.caption ||
    m?.videoMessage?.caption ||
    ''
  )
}

async function handleMessage(sock, msg) {
  const jid = msg.key.remoteJid
  const sender = msg.key.participant || jid
  const body = bodyOf(msg)
  if (!body || !body.startsWith(prefix())) return

  // Antiâ€‘spam: simple cooldown per user
  if (isSpamming(sender)) {
    return sock.sendMessage(jid, { text: 'âš ï¸ Slow down, you\'re sending commands too quickly.' }, { quoted: msg })
  }

  const args = body.slice(prefix().length).trim().split(/\s+/)
  const cmd = args.shift().toLowerCase()

  const handler = all[cmd]
  if (!handler) {
    return sock.sendMessage(jid, { text: `â“ Unknown command. Type ${prefix()}help` }, { quoted: msg })
  }

  const res = await handler({ sock, msg, args })
  if (!res) return
  if (typeof res === 'string') return sock.sendMessage(jid, { text: res }, { quoted: msg })
  return sock.sendMessage(jid, res, { quoted: msg })
}

module.exports = handleMessage
function prefix() { return process.env.PREFIX || '#' }
function owner()  { return process.env.OWNER_NUMBER || '' }
function botName(){ return process.env.BOT_NAME || 'SIANO-MD' }
module.exports = { prefix, owner, botName }
// 2.5s cooldown per user
const last = new Map()
function isSpamming(user) { const now = Date.now(); const t = last.get(user) || 0; if (now - t < 2500) return true; last.set(user, now); return false }
module.exports = { isSpamming }
const { getGroupSettings } = require('./store')
const WA_LINK = /chat\.whatsapp\.com\/[A-Za-z0-9]+/i

async function isAdmin(sock, jid, userJid) {
  const meta = await sock.groupMetadata(jid)
  const p = meta.participants.find(p => p.id === userJid)
  return !!p?.admin
}
async function isBotAdmin(sock, jid) {
  const meta = await sock.groupMetadata(jid)
  const me = (await sock.user.id)
  const bot = meta.participants.find(p => p.id === me)
  return !!bot?.admin
}

async function handleAntiLinkOnMessage(sock, m) {
  const jid = m.key.remoteJid
  if (!jid.endsWith('@g.us')) return // groups only

  const body = m.message?.conversation || m.message?.extendedTextMessage?.text || ''
  if (!body) return

  const settings = getGroupSettings(jid)
  if (!settings.antilink) return
  if (!WA_LINK.test(body)) return

  const sender = m.key.participant
  const admin = await isAdmin(sock, jid, sender)
  if (admin) return // ignore admins

  const botAdmin = await isBotAdmin(sock, jid)
  if (botAdmin) {
    try {
      await sock.sendMessage(jid, { text: `ğŸ”— Antiâ€‘link: @${sender.split('@')[0]} â€” removingâ€¦`, mentions: [sender] })
      await sock.groupParticipantsUpdate(jid, [sender], 'remove')
    } catch (e) {
      await sock.sendMessage(jid, { text: `âš ï¸ Antiâ€‘link triggered for @${sender.split('@')[0]} but I lack permissions.`, mentions: [sender] })
    }
  } else {
    await sock.sendMessage(jid, { text: `âš ï¸ Antiâ€‘link triggered by @${sender.split('@')[0]} â€” make me *admin* to enforce.`, mentions: [sender] })
  }
}

module.exports = { handleAntiLinkOnMessage }
const { #, SIANO-MD } = require('../utils/config')
module.exports = {
  help: async () => {
    const p = prefix()
    return [
      `ğŸ¤– *${botName()}* â€” Commands`,
      '',
      'ğŸ® *Fun*',
      `${p}dice, ${p}coin, ${p}rps <rock|paper|scissors>, ${p}meme, ${p}cat, ${p}dog`,
      '',
      'ğŸ–¼ï¸ *Media*',
      `${p}sticker (reply to image), ${p}play <song>, ${p}ytmp3 <url>, ${p}ytmp4 <url>`,
      '',
      'ğŸ‘‘ *Admin*',
      `${p}kick <@user>, ${p}add <number>, ${p}promote <@user>, ${p}demote <@user>, ${p}mute, ${p}unmute`,
      '',
      'ğŸ‘‹ *Welcome*',
      `${p}welcome on|off, ${p}setwelcome <message with @user>`,
      '',
      'ğŸ›¡ï¸ *Protection*',
      `${p}antilink on|off, ${p}antispam on|off`,
    ].join('\n')
  }
}
const axios = require('axios')
module.exports = {
  dice: async () => `ğŸ² You rolled: ${Math.floor(Math.random() * 6) + 1}`,
  coin: async () => `ğŸª™ ${Math.random() < 0.5 ? 'Heads' : 'Tails'}`,
  rps: async ({ args }) => {
    const you = (args[0] || '').toLowerCase()
    const opts = ['rock', 'paper', 'scissors']
    if (!opts.includes(you)) return 'Usage: #rps <rock|paper|scissors>'
    const bot = opts[Math.floor(Math.random() * 3)]
    const res = you === bot ? 'ğŸ¤ Draw!' :
      (you === 'rock' && bot === 'scissors') ||
      (you === 'scissors' && bot === 'paper') ||
      (you === 'paper' && bot === 'rock') ? 'âœ… You win!' : 'âŒ You lose!'
    return `You: ${you}\nBot: ${bot}\n${res}`
  },
  meme: async () => {
    const { data } = await axios.get('https://meme-api.com/gimme')
    return { image: { url: data.url }, caption: data.title }
  },
  cat: async () => {
    const { data } = await axios.get('https://api.thecatapi.com/v1/images/search')
    return { image: { url: data[0].url }, caption: 'ğŸ± Meow!' }
  },
  dog: async () => {
    const { data } = await axios.get('https://dog.ceo/api/breeds/image/random')
    return { image: { url: data.message }, caption: 'ğŸ¶ Woof!' }
  }
}
