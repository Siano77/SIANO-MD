mkdir md-bot && cd md-bot
npm init -y
md-bot/
│── package.json
│── .gitignore
│── .env.example
│── README.md
│── Procfile                 # optional (Heroku-style)
│── Dockerfile               # optional (Docker/VPS)
│
└── src/
    │── index.js
    │── handler.js
    │
    ├── utils/
    │   ├── config.js
    │   ├── store.js
    │   ├── spamGuard.js
    │   └── moderation.js
    │
    └── commands/
        ├── help.js
        ├── fun.js
        ├── media.js
        ├── admin.js
        ├── welcome.js
{
  "name": "Siano-MD",
  "version": "1.0.0",
  "description": "Wake Up To Reality 💥",
  "main": "src/index.js",
  "type": "commonjs",
  "license": "MIT",
  "scripts": {
    "start": "node src/index.js"
  },
  "dependencies": {
    "@whiskeysockets/baileys": "^6.7.7",
    "axios": "^1.7.4",
    "dotenv": "^16.4.5",
    "pino": "^9.3.2",
    "ytdl-core": "^4.11.5",
    "yt-search": "^2.10.6"
  }
}
node_modules
.env
session/
data/
PREFIX=#
OWNER_NUMBER=2347043387336
BOT_NAME=SIANO-MD
require('dotenv').config()
const pino = require('pino')
const { default: makeWASocket, useMultiFileAuthState, fetchLatestBaileysVersion, downloadMediaMessage } = require('@whiskeysockets/baileys')
const handleMessage = require('./handler')
const { getGroupSettings, ensureStore } = require('./utils/store')
const { handleAntiLinkOnMessage } = require('./utils/moderation')

const logger = pino({ level: 'info' })

async function start() {
  ensureStore()
  const { state, saveCreds } = await useMultiFileAuthState('session')
  const { version } = await fetchLatestBaileysVersion()

  const sock = makeWASocket({ version, logger, auth: state, printQRInTerminal: true })
  sock.ev.on('creds.update', saveCreds)

  // Main message pipeline
  sock.ev.on('messages.upsert', async ({ messages }) => {
    const m = messages[0]
    if (!m || !m.message) return

    // Anti‑link moderation for all texts
    try { await handleAntiLinkOnMessage(sock, m) } catch (e) { logger.warn({ e }, 'antilink check failed') }

    // Commands
    try { await handleMessage(sock, m) } catch (e) { logger.error({ e }, 'handler failed') }
  })

  // Welcome messages
  sock.ev.on('group-participants.update', async (update) => {
    try {
      const chat = update.id
      const settings = getGroupSettings(chat)
      if (!settings.welcome || update.action !== 'add') return
      const user = update.participants[0]
      const text = (settings.welcomeText || 'Welcome to the group, @user 🎉').replace(/@user/g, `@${user.split('@')[0]}`)
      await sock.sendMessage(chat, { text, mentions: [user] })
    } catch (e) { logger.warn({ e }, 'welcome failed') }
  })
}

start()
const { # } = require('./utils/config')
const { isSpamming } = require('./utils/spamGuard')
const fun = require('./commands/fun')
const media = require('./commands/media')
const admin = require('./commands/admin')
const welcome = require('./commands/welcome')
const help = require('./commands/help')

const all = { ...fun, ...media, ...admin, ...welcome, ...help }

function bodyOf(msg) {
  const m = msg.message
  return (
    m?.conversation ||
    m?.extendedTextMessage?.text ||
    m?.imageMessage?.caption ||
    m?.videoMessage?.caption ||
    ''
  )
}

async function handleMessage(sock, msg) {
  const jid = msg.key.remoteJid
  const sender = msg.key.participant || jid
  const body = bodyOf(msg)
  if (!body || !body.startsWith(prefix())) return

  // Anti‑spam: simple cooldown per user
  if (isSpamming(sender)) {
    return sock.sendMessage(jid, { text: '⚠️ Slow down, you\'re sending commands too quickly.' }, { quoted: msg })
  }

  const args = body.slice(prefix().length).trim().split(/\s+/)
  const cmd = args.shift().toLowerCase()

  const handler = all[cmd]
  if (!handler) {
    return sock.sendMessage(jid, { text: `❓ Unknown command. Type ${prefix()}help` }, { quoted: msg })
  }

  const res = await handler({ sock, msg, args })
  if (!res) return
  if (typeof res === 'string') return sock.sendMessage(jid, { text: res }, { quoted: msg })
  return sock.sendMessage(jid, res, { quoted: msg })
}

module.exports = handleMessage
function prefix() { return process.env.PREFIX || '#' }
function owner()  { return process.env.OWNER_NUMBER || '' }
function botName(){ return process.env.BOT_NAME || 'SIANO-MD' }
module.exports = { prefix, owner, botName }
// 2.5s cooldown per user
const last = new Map()
function isSpamming(user) { const now = Date.now(); const t = last.get(user) || 0; if (now - t < 2500) return true; last.set(user, now); return false }
module.exports = { isSpamming }
const { getGroupSettings } = require('./store')
const WA_LINK = /chat\.whatsapp\.com\/[A-Za-z0-9]+/i

async function isAdmin(sock, jid, userJid) {
  const meta = await sock.groupMetadata(jid)
  const p = meta.participants.find(p => p.id === userJid)
  return !!p?.admin
}
async function isBotAdmin(sock, jid) {
  const meta = await sock.groupMetadata(jid)
  const me = (await sock.user.id)
  const bot = meta.participants.find(p => p.id === me)
  return !!bot?.admin
}

async function handleAntiLinkOnMessage(sock, m) {
  const jid = m.key.remoteJid
  if (!jid.endsWith('@g.us')) return // groups only

  const body = m.message?.conversation || m.message?.extendedTextMessage?.text || ''
  if (!body) return

  const settings = getGroupSettings(jid)
  if (!settings.antilink) return
  if (!WA_LINK.test(body)) return

  const sender = m.key.participant
  const admin = await isAdmin(sock, jid, sender)
  if (admin) return // ignore admins

  const botAdmin = await isBotAdmin(sock, jid)
  if (botAdmin) {
    try {
      await sock.sendMessage(jid, { text: `🔗 Anti‑link: @${sender.split('@')[0]} — removing…`, mentions: [sender] })
      await sock.groupParticipantsUpdate(jid, [sender], 'remove')
    } catch (e) {
      await sock.sendMessage(jid, { text: `⚠️ Anti‑link triggered for @${sender.split('@')[0]} but I lack permissions.`, mentions: [sender] })
    }
  } else {
    await sock.sendMessage(jid, { text: `⚠️ Anti‑link triggered by @${sender.split('@')[0]} — make me *admin* to enforce.`, mentions: [sender] })
  }
}

module.exports = { handleAntiLinkOnMessage }
const { #, SIANO-MD } = require('../utils/config')
module.exports = {
  help: async () => {
    const p = prefix()
    return [
      `🤖 *${botName()}* — Commands`,
      '',
      '🎮 *Fun*',
      `${p}dice, ${p}coin, ${p}rps <rock|paper|scissors>, ${p}meme, ${p}cat, ${p}dog`,
      '',
      '🖼️ *Media*',
      `${p}sticker (reply to image), ${p}play <song>, ${p}ytmp3 <url>, ${p}ytmp4 <url>`,
      '',
      '👑 *Admin*',
      `${p}kick <@user>, ${p}add <number>, ${p}promote <@user>, ${p}demote <@user>, ${p}mute, ${p}unmute`,
      '',
      '👋 *Welcome*',
      `${p}welcome on|off, ${p}setwelcome <message with @user>`,
      '',
      '🛡️ *Protection*',
      `${p}antilink on|off, ${p}antispam on|off`,
    ].join('\n')
  }
}
const axios = require('axios')
module.exports = {
  dice: async () => `🎲 You rolled: ${Math.floor(Math.random() * 6) + 1}`,
  coin: async () => `🪙 ${Math.random() < 0.5 ? 'Heads' : 'Tails'}`,
  rps: async ({ args }) => {
    const you = (args[0] || '').toLowerCase()
    const opts = ['rock', 'paper', 'scissors']
    if (!opts.includes(you)) return 'Usage: #rps <rock|paper|scissors>'
    const bot = opts[Math.floor(Math.random() * 3)]
    const res = you === bot ? '🤝 Draw!' :
      (you === 'rock' && bot === 'scissors') ||
      (you === 'scissors' && bot === 'paper') ||
      (you === 'paper' && bot === 'rock') ? '✅ You win!' : '❌ You lose!'
    return `You: ${you}\nBot: ${bot}\n${res}`
  },
  meme: async () => {
    const { data } = await axios.get('https://meme-api.com/gimme')
    return { image: { url: data.url }, caption: data.title }
  },
  cat: async () => {
    const { data } = await axios.get('https://api.thecatapi.com/v1/images/search')
    return { image: { url: data[0].url }, caption: '🐱 Meow!' }
  },
  dog: async () => {
    const { data } = await axios.get('https://dog.ceo/api/breeds/image/random')
    return { image: { url: data.message }, caption: '🐶 Woof!' }
  }
}
const { downloadMediaMessage } = require('@whiskeysockets/baileys')
const yts = require('yt-search')
const ytdl = require('ytdl-core')

module.exports = {
  // image → sticker
  sticker: async ({ sock, msg }) => {
    if (!msg.message?.imageMessage) return 'Reply to an *image* with #sticker'
    const buffer = await downloadMediaMessage(msg, 'buffer', {}, { logger: sock.logger, reuploadRequest: sock.updateMediaMessage })
    return { sticker: buffer }
  },

  // search & reply with top video link
  play: async ({ args }) => {
    const q = args.join(' ')
    if (!q) return 'Usage: #play <song>'
    const res = await yts(q)
    const v = res.videos?.[0]
    if (!v) return '❌ No results found.'
    return `🎵 *${v.title}*\n⏱️ ${v.timestamp}\n👤 ${v.author.name}\n🔗 ${v.url}`
  },

  // YouTube → audio (m4a/mp4a)
  ytmp3: async ({ args }) => {
    const url = args[0]
    if (!url || !ytdl.validateURL(url)) return 'Usage: #ytmp3 <youtube-url>'
    const info = await ytdl.getInfo(url)
    const format = ytdl.chooseFormat(info.formats, { quality: '140' }) || ytdl.chooseFormat(info.formats, { filter: 'audioonly' })
    const chunks = []
    return await new Promise((resolve, reject) => {
      ytdl.downloadFromInfo(info, { format })
        .on('data', c => chunks.push(c))
        .on('end', () => resolve({ audio: Buffer.concat(chunks), mimetype: 'audio/mp4', ptt: false, fileName: (info.videoDetails.title || 'audio') + '.m4a' }))
        .on('error', err => resolve('❌ Download failed.'))
    })
  },

  // YouTube → video (mp4 itag 18 when possible)
  ytmp4: async ({ args }) => {
    const url = args[0]
    if (!url || !ytdl.validateURL(url)) return 'Usage: #ytmp4 <youtube-url>'
    const info = await ytdl.getInfo(url)
    const format = ytdl.chooseFormat(info.formats, { quality: '18' }) || ytdl.chooseFormat(info.formats, { filter: f => f.container === 'mp4' && f.hasVideo })
    const chunks = []
    return await new Promise((resolve, reject) => {
      ytdl.downloadFromInfo(info, { format })
        .on('data', c => chunks.push(c))
        .on('end', () => resolve({ video: Buffer.concat(chunks), mimetype: 'video/mp4', fileName: (info.videoDetails.title || 'video') + '.mp4' }))
        .on('error', err => resolve('❌ Download failed.'))
    })
  }
}
const { setGlobal, getGlobal, setGroupSetting } = require('../utils/store')

async function requireGroup(msg) { return msg.key.remoteJid.endsWith('@g.us') }

module.exports = {
  kick: async ({ sock, msg, args }) => {
    const inGroup = await requireGroup(msg); if (!inGroup) return 'Group only.'
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0]
    if (!mentioned && !args[0]) return 'Tag a user or provide number.'
    const target = mentioned || (args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net')
    await sock.groupParticipantsUpdate(msg.key.remoteJid, [target], 'remove')
    return `👢 Kicked @${target.split('@')[0]}`
  },
  add: async ({ sock, msg, args }) => {
    const inGroup = await requireGroup(msg); if (!inGroup) return 'Group only.'
    if (!args[0]) return 'Usage: #add <number>'
    const target = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'
    await sock.groupParticipantsUpdate(msg.key.remoteJid, [target], 'add')
    return `➕ Invited ${args[0]}`
  },
  promote: async ({ sock, msg, args }) => {
    const inGroup = await requireGroup(msg); if (!inGroup) return 'Group only.'
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0]
    if (!mentioned && !args[0]) return 'Tag a user or provide number.'
    const target = mentioned || (args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net')
    await sock.groupParticipantsUpdate(msg.key.remoteJid, [target], 'promote')
    return `👑 Promoted @${target.split('@')[0]}`
  },
  demote: async ({ sock, msg, args }) => {
    const inGroup = await requireGroup(msg); if (!inGroup) return 'Group only.'
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0]
    if (!mentioned && !args[0]) return 'Tag a user or provide number.'
    const target = mentioned || (args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net')
    await sock.groupParticipantsUpdate(msg.key.remoteJid, [target], 'demote')
    return `⬇️ Demoted @${target.split('@')[0]}`
  },
  mute: async ({ sock, msg }) => { await sock.groupSettingUpdate(msg.key.remoteJid, 'announcement'); return '🔒 Group muted (admins only)' },
  unmute: async ({ sock, msg }) => { await sock.groupSettingUpdate(msg.key.remoteJid, 'not_announcement'); return '🔓 Group unmuted (everyone can send)' },
  antilink: async ({ msg, args }) => { const onoff = (args[0]||'').toLowerCase(); if(!['on','off'].includes(onoff)) return 'Usage: #antilink on|off'; setGroupSetting(msg.key.remoteJid,'antilink', onoff==='on'); return `🔗 Anti‑link ${onoff==='on'?'enabled':'disabled'}` },
  antispam: async ({ args }) => { const onoff = (args[0]||'').toLowerCase(); if(!['on','off'].includes(onoff)) return 'Usage: #antispam on|off'; setGlobal('antispam', onoff==='on'); return `⚡ Anti‑spam ${onoff==='on'?'enabled':'disabled'}` }
}
const { setGroupSetting } = require('../utils/store')
module.exports = {
  welcome: async ({ msg, args }) => {
    const onoff = (args[0] || '').toLowerCase()
    if (!['on','off'].includes(onoff)) return 'Usage: #welcome on|off'
    setGroupSetting(msg.key.remoteJid, 'welcome', onoff==='on')
    return `👋 Welcome messages ${onoff==='on'?'enabled':'disabled'}`
  },
  setwelcome: async ({ msg, args }) => {
    const text = args.join(' ')
    if (!text) return 'Usage: #setwelcome <message — use @user>'
    setGroupSetting(msg.key.remoteJid, 'welcomeText', text)
    return '✅ Custom welcome message saved.'
  }
}
